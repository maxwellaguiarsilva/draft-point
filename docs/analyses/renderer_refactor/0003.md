## 0003: Segurança de Tipo e Iteração Espacial

Padrões idiomáticos e de segurança que garantem a integridade do design elevado.

### 1. Segurança de Domínio via Tipagem Forte
Para impedir o uso acidental de coordenadas de pixel em funções que esperam células, utilizamos *tags* de tipo e namespaces organizados na camada `tui`:
```cpp
__using( ::sak, ::point );

namespace pixel {
    using point = point< int, 2, struct pixel_tag >;
}

namespace cell {
    using point = point< int, 2, struct cell_tag >;
}
```

Esta distinção em tempo de compilação força o uso de transformadores explícitos, tornando o código auto-documentado e robusto contra erros de lógica espacial.

### 2. Incompatibilidade e Segurança ( Non-Interoperability )
A herança privada de `std::array` e a parametrização por `t_tag` garantem que:
- **Sem Comparação Acidental:** `pixel::point == cell::point` resultará em erro de compilação, impedindo a mistura semântica de domínios.
- **Sem Conversão Implícita:** Apenas transformadores nomeados ( ex: `to_cell` ) permitem a transição entre espaços.
- **Isolamento de Operadores:** Operadores matemáticos preservam a tag, garantindo que `pixel::point + pixel::point = pixel::point`.

### 3. Iteração com Consciência Espacial
A iteração sobre os buffers de exibição é elevada para um modelo de "dados com contexto":
```cpp
//	iteração elevada: sem índices manuais, apenas dados e posição
for( auto&& [ position, back_cell ] : m_back_view->elements( ) )
{
    auto& front_cell = ( *m_front_view )[ position ];
    if( back_cell not_eq front_cell )
    {
        m_terminal.move_cursor( position );
        m_terminal.draw_cell( back_cell );
        front_cell = back_cell;
    }
}
```
O método `.elements( )` encapsula a derivação da posição, permitindo que o `renderer` foque puramente na política de sincronização.

### 3. Geometria como Fluxo ( Generators )
Algoritmos complexos como o Bresenham são removidos do corpo do renderizador e transformados em geradores de pontos:
```cpp
namespace pixel {
    auto trace_line( point start, point end ) -> ::std::generator< point >;
}

void renderer::draw( pixel::line const& data )
{
    for( pixel::point point : pixel::trace_line( data.start, data.end ) )
        draw( point );
}
```
A infraestrutura `trace_line` fornece uma `::std::generator`, tratando a geometria como um fluxo de dados.

### 4. Orquestração e Maturidade
O renderizador atua como um orquestrador de políticas de exibição. A complexidade matemática e de acesso reside em bibliotecas testadas ( `sak` e `geometry` ), resultando em um código focado na intenção de design.


