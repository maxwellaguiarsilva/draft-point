## 0004: Blueprint de Implementação

Este documento é o guia de execução mecânica para a refatoração do sistema de renderização. Nenhuma decisão de design deve ser tomada durante a implementação; siga as assinaturas e lógicas descritas.

### 1. Infraestrutura: Elevação da `sak::point`
**Arquivo:** `include/sak/geometry/point.hpp`

**Alteração 1: Adição de Tag de Domínio e Segurança**
Modificar a assinatura da classe para aceitar um terceiro parâmetro de template e tornar os construtores mais rigorosos. Adicionar operadores de comparação explícitos para evitar ambiguidades com a base privada.
```cpp
template< is_arithmetic t_scalar = int, size_t num_dimensions = 2, typename t_tag = void >
class point final : private array< t_scalar, num_dimensions >
{
public:
	// ...
	constexpr point( ) : super_type{ } { }

	template< typename... t_args >
		requires( sizeof...( t_args ) == num_dimensions
			and ( ( is_arithmetic< t_args > or convertible_to< t_args, t_scalar > ) and ... )
		)
	constexpr explicit point( t_args... a_args )
		: super_type{ static_cast< t_scalar >( a_args )... }
	{
	}

	constexpr auto operator == ( const point& other ) const noexcept -> bool { return is_all( other, equal_to ); }
	constexpr auto operator != ( const point& other ) const noexcept -> bool { return not ( *this == other ); }
```
Atualizar o trait `__is_point` e a concept `is_point` para suportar a tag:
```cpp
template< is_arithmetic t_scalar, size_t num_dimensions, typename t_tag >
struct __is_point< point< t_scalar, num_dimensions, t_tag > > : true_type { };
```

**Alteração 2: Método `map`**
Adicionar o método `map` para transformações unárias, preservando a tag. Utilizar `decltype` para deduzir o novo tipo escalar ( ex: `int` para `float` em normalizações ).
```cpp
template< typename t_operation >
constexpr auto map( t_operation&& operation ) const noexcept
{
	using t_new_scalar = decltype( operation( t_scalar{ } ) );
	point< t_new_scalar, num_dimensions, t_tag > result;
	transform( *this, result.begin( ), operation );
	return	result;
}
```

### 2. Definições de Domínio TUI
**Arquivo:** `include/tui/geometry.hpp`

**Remover completamente** a definição `using point = ...` e `using geometry = ...`. Substituir pelas novas definições de domínio:
```cpp
namespace tui {

using	pixel		=	::sak::point< int, 2, struct pixel_tag >;
using	cell_point	=	::sak::point< int, 2, struct cell_tag >;

using	pixel_geometry	=	::sak::geometry< pixel >;
using	pixel_line		=	pixel_geometry::line;
using	pixel_rectangle	=	pixel_geometry::rectangle;

//	transformadores de domínio
inline constexpr auto to_cell( pixel const& position ) noexcept -> cell_point
{
	return	cell_point{ position[ 0 ], ( position[ 1 ] + 1 ) / 2 };
}

inline constexpr auto is_upper( pixel const& position ) noexcept -> bool
{
	return	::sak::math::is_odd( position[ 1 ] );
}

}
```

### 3. Alinhamento de Maquinaria ( Terminal )
**Arquivo:** `include/tui/terminal.hpp` e `source/tui/terminal.cpp`

Substituir todas as referências ao antigo `point` por `cell_point`. O terminal opera estritamente no domínio de células.

### 4. Abstração de Acesso: `surface_view`
**Arquivo:** `include/tui/surface.hpp` ( Novo Arquivo )

Implementar uma visão que mapeia coordenadas 2D para um buffer linear:
```cpp
namespace tui {

template< typename t_data, typename t_point_type >
class surface_view
{
public:
	surface_view( t_data* data, t_point_type size ) 
		: m_data( data ), m_size( size ) { }

	auto operator []( t_point_type const& position ) noexcept -> t_data&
	{
		//	linearização elevada: vertical * width + horizontal
		return	m_data[ ( position[ 1 ] - 1 ) * m_size[ 0 ] + ( position[ 0 ] - 1 ) ];
	}

private:
	t_data*      m_data;
	t_point_type m_size;
};

}
```

### 4. Orquestração no Renderizador
**Arquivo:** `source/tui/renderer.cpp`

**Alteração 1: Método `draw( pixel const& )`**
Remover cálculos manuais de índice. Utilizar transformadores e `surface_view`.
```cpp
void renderer::draw( pixel const& position ) noexcept
{
	__using( ::std, ::lock_guard );

	auto lock = lock_guard( m_mutex );
	if( not is_inside( position ) ) return; //	implementar is_inside com base em m_terminal_size

	auto target_cell = to_cell( position );
	auto& data = m_back_view[ target_cell ]; //	m_back_view deve ser membro da classe

	if( is_upper( position ) )
		data.up = m_color;
	else
		data.down = m_color;
}
```

**Alteração 2: Ciclo de Sincronização (`refresh`)**
Eliminar contadores `row`/`column`. Utilizar um iterador espacial ( a ser implementado na `surface_view` ou via gerador ).

### 5. Geometria como Fluxo
**Arquivo:** `include/tui/geometry.hpp`

Adicionar o gerador `trace_line` utilizando o algoritmo de Bresenham, retornando um `std::ranges::view` de `pixel`.
O executor deve mover a lógica atual de `renderer::draw( ::sak::geometry< pixel >::line )` para esta função.


