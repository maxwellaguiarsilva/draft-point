## 0005: Detalhamento Algorítmico e Sincronização ( Design )

Este documento detalha as políticas de fluxo de dados e os algoritmos elevados para a renderização.

### 1. Extensões Matemáticas
Para suportar o mapeamento de pontos ( `point::map` ), a `sak` deve prover funções unárias elevaras como `sign` e `abs`. Estas funções devem ser agnósticas e operar sobre escalares aritméticos.

### 2. Iteração Espacial na `surface_view`
O método `elements( )` da `surface_view` é o coração da sincronização de buffers. Ele deve ser implementado utilizando `std::views` para garantir:
- **Lazy Evaluation**: A derivação da posição 2D a partir do índice linear ocorre apenas sob demanda.
- **Imunidade a Ordem**: A lógica do renderizador deve funcionar independentemente da ordem em que os elementos são visitados.

### 3. Gerador de Linha ( Bresenham Elevado )
O algoritmo de Bresenham é removido da lógica interna do renderizador e encapsulado em um gerador `trace_line`.
- **Natureza**: Um gerador C++23 ( `std::generator` ).
- **Interface**: Retorna um fluxo de `pixel::point`.
- **Vantagem**: Permite que o renderizador trate o desenho de linhas como um simples loop sobre uma sequência de dados, ignorando a complexidade do cálculo do erro acumulado.

### 4. Ciclo de Sincronização (`refresh`)
O método `refresh` torna-se um consumidor da `surface_view`. Sua responsabilidade limita-se a:
1. Comparar as células nas mesmas posições espaciais entre o buffer frontal e o traseiro.
2. Comandar o terminal para atualizar apenas as posições divergentes.
3. Sincronizar os buffers após a atualização.