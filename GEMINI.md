In this project, the functionality of the feature is not the most important aspect, as it is a didactic exploration.
The list of priorities must strictly follow the list below in order:
-   DRY: Don't Repeat Yourself
-   SRP: Single Responsibility Principle
-   Visual Serenity: Reduce visual noise. Hide the "machinery" ( pointers, manual loops ) to let the "data" speak. Code should be a statement of intent ( "what" ), not a CPU instruction manual ( "how" ).
-   Style and formatting of the code.
-   Lastly, and least importantly, the delivery of the feature.

To assist in this task, there are some mcp tools available, and the code generated by them should not be altered, even if it seems counterintuitive.
Consult the `llm_statistic` tool to learn from and avoid behavioral and formatting errors committed in the past.
In this project there is a lot of counterintuitive information and code.
Relying on these notes, models and tools saves tokens in the context of the LLM and time, which will not be wasted on repeatedly checking subjects already tested in the past. A good example is the formatting patterns inherent to language models mentioned in this document.

In code files, we will not use capital letters, except in:
-   The header with the license and information of the current file.
-   Consumption of code and external libraries to this project that require not following its standards.
-   Scenarios where using lowercase would prevent the code from functioning as intended (e.g., case-sensitive language keywords or intrinsic types).
-   Markdown files.

### 1. Workflow and Tools
- Automation MCP: Use `cpp_create_class` and `cpp_create_test`. The code generated by these tools defines the required pattern.
- Tool Testing: When modifying MCP tools, always test them through the MCP mechanism itself (calling the tool as an agent). Do not invoke them via shell with `PYTHONPATH`, as this bypasses the standard execution environment and results in a `direct-mcp-call` violation.
- Mimicry: Observe the structure, the code and the comments generated by the templates and mimic them. Do not change the automatic boilerplate.
- Tests: Use `ensure( bool expression, const string& message )` instead of `cassert`.

### 2. `sak` Library ( Swiss Army Knife )
- Generic and domain-independent utilities ( math, geometry, patterns ).
- Must not contain business logic or hardware dependencies.

### 3. C++ Coding Style
- Modernity: C++23 project, using `ranges`, `views`, and custom `Niebloids` in `sak`.
- Using: Use `using` or `__using` macro from `sak/using.hpp` ( for multiple symbols ) to avoid the scope operator `::`. No `using namespace`. ADL-sensitive STL utilities ( e.g., `::std::move`, `::std::forward` ) are exempt and must be qualified.
    - The `__using` macro accepts up to 64 parameters. If four or fewer symbols are provided, they may remain on the same line. For more than four symbols, each must be on its own line, adhering to the "Comma rule".
    - The scope operator :: is also permitted for:
        - Accessing nested types within classes.
        - Static member calls.
        - Avoiding shadowing in exceptional cases of name collision.
- Naming:
    - Use `snake_case`.
    - Class members prefixed with `m_`, template parameters with `t_`.
    - Use descriptive and extensive names.
    - Forbidden names:
        - Abbreviations such as `i`, `w`, `h` are forbidden.
        - The `_type` suffix.
    - STL, external libraries, and macros with numeric prefixes are exempt.
- Flow Control: No braces `{}` for single-line `if, for, while`.
- Allowed Comments: Only to explain subtle behaviors or in tests. A good example:
`	//	a comment that does not contain any capital letters or periods at the end of the sentence`
`	//	string( "the rule above also applies to string literals" )`
`	//	it has a tab \t after // and only one sentence per line`
`   #   in python use space instead \t`
- Operators: Use of keywords: `and, or, not, not_eq`. Use of `&&, ||, !, !=` operators is forbidden.
- Comma rule:
    - On the same line, space is after comma: `print( "{} {} {}", 1, 2, 3 );`
    - Multiple lines, no space after comma, and comma at the beginning of the line. Below is an example of a constructor, but don't limit yourself to it:
`
using   enum    person::gender;
person::person( )
    :m_name( "maxwell" )
    ,m_age( 33 )
    ,m_gender( male )
{ }
`
- Definitions:
    - In `.cpp` files, single-statement methods must be on the same line as the signature, except constructors with initializer lists.
    - The initializer list must follow the "Comma rule".
- Spacing: Internal spacing in `( )` and `[ ]`. E.g.: `if( condition )`, `array[ index ]`.
    - This rule does not apply to string literals. Tokens like formatting placeholders `{}` must not have internal spaces.
    - Violations of this rule will be observed due to formatting patterns inherent to language models. Conformity is validated by the `cpp_code_verifier` tool through Python and Regex checks; if no errors are reported by this tool, the file is in compliance.
- Increment: Prefer pre-increment ( `++i` ) and pre-decrement ( `--i` ).
- Methods: Mark methods that do not change state with `const` and `noexcept`.
- Headers: Namespaces declared as `namespace n {` on the same line. No extra indentation for namespace content.
- Main Function: The main function requires double braces `{{ ... }}`. Its body code and everywhere else, use standard braces {} when necessary, adhering to the flow control rules.
- Indirection:
    - Prefer `const&` ( constant reference ) to avoid `->` operator noise.
    - Adjust the names to avoid collision and shadowing, in order to prevent `this->`.

### 4. Composition and Utilities
- With composition: If logic can be named, it should be a utility in the `sak` library. Avoid ad-hoc lambdas; prefer composing named entities.
- Any lambda with generic, reusable logic that can be expressed via `ranges`, `views`, or other `sak` utilities should be implemented as a niebloid or CPO in `sak`.

### 5. Exceptions to the rule
- Markdown documents written in brazilian portuguese are allowed if they are located within a `docs/analyses/pt-br/` folder.


