In this project, the style and formatting of the code are more important than whether the code works or compiles.
To assist in this task, there are some mcp tools available, and the code generated by them should not be altered, even if it seems counterintuitive.
In this project there is a lot of counterintuitive information and code.
Relying on these notes, models and tools saves tokens in the context of the LLM and time, which will not be wasted on repeatedly checking subjects already tested in the past. A good example is the formatting patterns inherent to language models mentioned in this document.

### 1. Workflow and Tools
- Automation MCP: Use `create_class` and `create_test`. The code generated by these tools defines the required pattern.
- Mimicry: Observe the structure, the order of includes, and the comments generated by the templates and mimic them. Do not change the automatic boilerplate.
- Tests: Use `::sak::ensure( bool expression, const string& message )` instead of `cassert`.
- When adding empty lines at the end of files, use `run_shell_command` with `printf` to ensure precision, avoiding the use of `write_file` or `replace`, as they apply automatic trimming and remove the required newlines.
- Verification: 
    1.  Use the `analyze` tool after changes to run static analysis ( cppcheck ) and apply automatic formatting fixes.
    2.  Use the `verify_formatting` MCP tool.
    3.  Use the `compile` tool for incremental building and linking. This tool should be used last.

### 2. `sak` Library ( Swiss Army Knife )
- Generic and domain-independent utilities ( math, geometry, patterns ).
- Must not contain business logic or hardware dependencies.

### 3. C++ Coding Style
- Modernity: C++23 project, using `ranges`, `views`, and custom `Niebloids` in `sak`.
- Using: Use `using` or `__using` macro from `sak/using.hpp` ( for multiple symbols ) to avoid the scope operator `::`. No `using namespace`. ADL-sensitive STL utilities ( e.g., `::std::move`, `::std::forward` ) are exempt and must be qualified.
- Naming: Use `snake_case`. Class members prefixed with `m_`, template parameters with `t_`. Use descriptive and extensive names; abbreviations such as `i`, `w`, `h` are forbidden. STL, external libraries, and macros with numeric prefixes are exempt.
- Flow Control: No braces `{}` for single-line `if, for, while`.
- Allowed Comments: Only to explain subtle behaviors or in tests. A good example:
`	//	a comment that does not contain any capital letters or periods at the end of the sentence`
`	//	string( "the rule above also applies to string literals" )`
`	//	it has a tab \t after // and only one sentence per line`
- Operators: Use of keywords: `and, or, not, not_eq`. Use of `&&, ||, !, !=` operators is forbidden.
- Comma rule:
    - On the same line, space is after comma: `print( "{} {} {}", 1, 2, 3 );`
    - Multiple lines, no space after comma, and comma at the beginning of the line. Below is an example of a constructor, but don't limit yourself to it:
`
using   enum    person::gender;
person::person( )
    :m_name( "maxwell" )
    ,m_age( 33 )
    ,m_gender( male )
{ }
`
- Definitions:
    - In `.cpp` files, single-statement methods must be on the same line as the signature, except constructors with initializer lists.
    - The initializer list must follow the "Comma rule".
- Spacing: Internal spacing in `( )` and `[ ]`. E.g.: `if( condition )`, `array[ index ]`.
    - This rule does not apply to string literals. Tokens like formatting placeholders `{}` must not have internal spaces.
    - Violations of this rule will be observed due to formatting patterns inherent to language models. Conformity is validated by the `verify_formatting` tool through Python and Regex checks; if no errors are reported by this tool, the file is in compliance.
- Increment: Prefer pre-increment ( `++i` ) and pre-decrement ( `--i` ).
- Methods: Mark methods that do not change state with `const` and `noexcept`.
- Headers: Namespaces declared as `namespace n {` on the same line. No extra indentation for namespace content.
- Main Function: The main function requires double braces `{{ ... }}`. Its body code and everywhere else, use standard braces {} when necessary, adhering to the flow control rules.
- Indirection: Prefer `const&` ( constant reference ) to avoid `->` operator noise.

### 4. Semantic Elevation
- Data over Machinery: Hide the "machinery" ( pointers, manual loops ) to let the "data" speak.
- Visual Serenity: Reduce visual noise. Code should be a statement of intent ( "what" ), not a CPU instruction manual ( "how" ).
- With composition: If logic can be named, it should be a utility in the `sak` library. Avoid ad-hoc lambdas; prefer composing named entities.
- Any lambda with generic, reusable logic that can be expressed via `ranges`, `views`, or other `sak` utilities should be implemented as a niebloid or CPO in `sak`.


