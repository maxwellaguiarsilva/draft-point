#!/bin/bash


#	variables for license header placeholders
num_year=$( date +%Y )
des_full_name="$( git config --global user.name )"
des_email="$( git config --global user.email )"
des_formatted_datetime="$( date "+%Y-%m-%d %H:%M" )"

#	input parameter: class hierarchy ( e.g., tui/screen )
class_hierarchy="${1}"

if [[ -z "${class_hierarchy}" ]];
then
	echo "usage: ${0} <class_hierarchy>"
	echo "example: ${0} tui/screen"
	exit 1
fi

#	extract class name and namespace path
class_name=$( basename "${class_hierarchy}" )
namespace_path=$( dirname "${class_hierarchy}" )

#	convert namespace path to actual namespace string ( e.g., tui/screen -> namespace tui { ... } )
namespace_open=""
namespace_close=""
if [[ "${namespace_path}" != "." ]];
then
	#	split by '/' and create nested namespaces
	IFS='/' read -ra address_list <<< "${namespace_path}"
	for namespace_part in "${address_list[@]}"
	do
		namespace_open+="namespace ${namespace_part}
{
"
		namespace_close+="}
"
	done
fi

#	construct file paths
output_dir="include/${namespace_path}"
output_file="${output_dir}/${class_name}.hpp"
des_file_path="${class_hierarchy}.hpp"

#	create output directory if it doesn't exist
mkdir -p "${output_dir}"

#	generate unique header guard number
hpp_number="$( date "+%N" )"
header_guard="hpp${hpp_number}"

#	read license header template
license_header_template="$( cat docs/license_header.txt )"

#	replace placeholders in license header
license_header=$( echo "${license_header_template}" | \
	sed "s|{num_year}|${num_year}|g" | \
	sed "s|{des_full_name}|${des_full_name}|g" | \
	sed "s|{des_email}|${des_email}|g" | \
	sed "s|{des_file_path}|${des_file_path}|g" | \
	sed "s|{des_formatted_datetime}|${des_formatted_datetime}|g" )

#	generate c++ class content
cpp_content="
#pragma once
#ifndef ${header_guard}
#define ${header_guard}

"

if [[ -n "${namespace_open}" ]];
then
	cpp_content+="${namespace_open}"
fi

cpp_content+="

class ${class_name}
{
public:
	${class_name}( );
	virtual ~${class_name}( );

	${class_name}( const ${class_name}& ) = delete;
	${class_name}& operator=( const ${class_name}& ) = delete;
	${class_name}( ${class_name}&& ) = delete;
	${class_name}& operator=( ${class_name}&& ) = delete;
};

"

if [[ -n "${namespace_close}" ]];
then
	cpp_content+="${namespace_close}"
fi

cpp_content+="
#endif
"

#	combine license header and c++ content and write to file
echo -e "${license_header}
${cpp_content}" > "${output_file}"

echo "created ${output_file}"

