#!/usr/bin/python3


import sys
import os
import subprocess
import json
from fastmcp import FastMCP


#   create an mcp server instance
mcp = FastMCP( name="project-tools-mcp" )


def _call( args: list[ str ] ) -> subprocess.CompletedProcess:
    """Internal helper to run subprocess with consistent parameters."""
    return subprocess.run( args, capture_output=True, text=True, check=True )


def _run_and_format( args: list[ str ], success_label: str = None, error_label: str = "Error" ) -> str:
    """Runs a command and formats the output for MCP return."""
    try:
        process = _call( args )
        return f"{success_label}\n{process.stdout}" if success_label else process.stdout
    except subprocess.CalledProcessError as e:
        details = f"{e.stdout}\n{e.stderr}".strip( )
        return f"{error_label}\n{details}" if success_label else f"{error_label}: {details}"
    except Exception as e:
        return f"{error_label}: {str( e )}"


@mcp.tool( )
def	create_class(
         class_hierarchy : str
        ,include_list: list[ str ] = [ ]
        ,using_list: list[ str ] = [ ]
        ,create_header_only: bool = False
    ) -> str:
    """Creates a new C++ class with corresponding .hpp and .cpp files.
    The class_hierarchy parameter defines the namespace and class name (e.g., "game/player" creates class 'player' in namespace 'game').
    Optional include_list and using_list parameters allow specifying additional headers to include and 'using' declarations to add.
    Good Example: include_list=["string", "vector"], using_list=["::std::string", "::std::vector", "item_list   =   vector< string >"]
    Bad Example: include_list="<string>", using_list="using std::string;"
    """
    args = {
        "class_hierarchy": class_hierarchy,
        "include_list": include_list,
        "using_list": using_list,
        "create_header_only": create_header_only
    }
    return _run_and_format( 
        [ "python3", "tools/file_generator.py", "create_class", json.dumps( args ) ], 
        error_label="Error creating class" 
    )


@mcp.tool( )
def create_test(
         hierarchy: str
        ,flg_adhoc: bool = False
        ,include_list: list[ str ] = [ ]
    ) -> str:
    """Creates a new C++ test file.
    If flg_adhoc is True, creates an adhoc test in tests/adhoc/NNNN_hierarchy/.
    If flg_adhoc is False, creates a structured test in tests/path/test_path_hierarchy.cpp.
    """
    args = {
        "hierarchy": hierarchy,
        "flg_adhoc": flg_adhoc,
        "include_list": include_list
    }
    return _run_and_format( 
        [ "python3", "tools/file_generator.py", "create_test", json.dumps( args ) ], 
        error_label="Error creating test" 
    )


@mcp.tool( )
def compile( ) -> str:
    """Compiles the project using project-builder.py. This command takes no arguments."""
    return _run_and_format( 
        [ "python3", "tools/project-builder.py" ], 
        success_label="Build successful:", 
        error_label="Build failed:" 
    )


@mcp.tool( )
def analyze( ) -> str:
    """Runs static analysis (cppcheck) and automatically fixes formatting rules.
    Beyond checking, it also applies fixes for the rules verified by 'verify_formatting' (newlines, return spacing, etc.) on all .cpp and .hpp files.
    This command takes no arguments."""
    return _run_and_format( 
        [ "python3", "tools/project-builder.py", "--analyze" ], 
        success_label="Static analysis successful:", 
        error_label="Static analysis failed:" 
    )


def _verify_loop( files: list[ str ], command_flag: str, label: str ) -> str:
    """Internal helper to iterate over files and collect violations."""
    if isinstance( files, str ):
        files = [ files ]

    results = [ ]
    for file_path in files:
        try:
            process = _call( [ "python3", "tools/code_verifier.py", command_flag, file_path ] )
            violations = json.loads( process.stdout )
            
            if violations:
                message = f"File: {file_path}\n"
                for line, violation in violations:
                    message += f"  Line {line}: {violation}\n"
                results.append( message )
        except Exception as e:
            results.append( f"Error verifying {file_path}: {str(e)}" )
    
    return "\n".join( results ).strip( ) or f"No {label} violations found in the provided files."


@mcp.tool( )
def verify_spacing( files: list[ str ] ) -> str:
    """Verifies if a list of files follows the ( space ) and [ space ] rules.
    Returns a consolidated list of violations with line numbers.
    Useful for distinguishing between real violations and LLM false positives.
    """
    return _verify_loop( files, "--spacing", "spacing" )
    

@mcp.tool( )
def verify_formatting( files: list[ str ] ) -> str:
    """Verifies if a list of files follows the project's formatting rules (newlines, return spacing, etc.).
    Returns a consolidated list of violations.
    """
    return _verify_loop( files, "--formatting", "formatting" )
    

@mcp.tool( )
def adhoc_tool( params: dict ) -> str:
    """Executes experimental logic defined in tools/adhoc_tool.py.
    This tool is used for prototyping new functionalities.
    The 'params' dictionary is passed to the script.
    """
    return _run_and_format( 
        [ "python3", "tools/adhoc_tool.py", json.dumps( params ) ], 
        error_label="Error executing adhoc tool" 
    )


if __name__ == "__main__":
    mcp.run()

