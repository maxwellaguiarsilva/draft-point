#!/usr/bin/python3


import sys
import os
import subprocess
import json
from fastmcp import FastMCP


#   create an mcp server instance
mcp = FastMCP( name="project-tools-mcp" )


@mcp.tool( )
def	create_class(
         class_hierarchy : str
        ,include_list: list[ str ] = [ ]
        ,using_list: list[ str ] = [ ]
        ,create_header_only: bool = False
    ) -> str:
    """Creates a new C++ class with corresponding .hpp and .cpp files.
    The class_hierarchy parameter defines the namespace and class name (e.g., "game/player" creates class 'player' in namespace 'game').
    Optional include_list and using_list parameters allow specifying additional headers to include and 'using' declarations to add.
    Good Example: include_list=["string", "vector"], using_list=["::std::string", "::std::vector", "item_list   =   vector< string >"]
    Bad Example: include_list="<string>", using_list="using std::string;"
    """
    args = {
        "class_hierarchy": class_hierarchy,
        "include_list": include_list,
        "using_list": using_list,
        "create_header_only": create_header_only
    }
    try:
        process = subprocess.run( 
            [ "python3", "tools/file_generator.py", "create_class", json.dumps( args ) ], 
            capture_output=True, text=True, check=True 
        )
        return process.stdout
    except subprocess.CalledProcessError as e:
        return f"Error creating class: {e.stderr}"


@mcp.tool( )
def create_test(
         hierarchy: str
        ,flg_adhoc: bool = False
        ,include_list: list[ str ] = [ ]
    ) -> str:
    """Creates a new C++ test file.
    If flg_adhoc is True, creates an adhoc test in tests/adhoc/NNNN_hierarchy/.
    If flg_adhoc is False, creates a structured test in tests/path/test_path_hierarchy.cpp.
    """
    args = {
        "hierarchy": hierarchy,
        "flg_adhoc": flg_adhoc,
        "include_list": include_list
    }
    try:
        process = subprocess.run( 
            [ "python3", "tools/file_generator.py", "create_test", json.dumps( args ) ], 
            capture_output=True, text=True, check=True 
        )
        return process.stdout
    except subprocess.CalledProcessError as e:
        return f"Error creating test: {e.stderr}"


@mcp.tool( )
def compile( ) -> str:
    """Compiles the project using project-builder.py. This command takes no arguments."""
    try:
        process = subprocess.run( [ "python3", "tools/project-builder.py" ], capture_output=True, text=True )
        if process.returncode == 0:
            return  f"Build successful:\n{process.stdout}"
        else:
            return  f"Build failed:\n{process.stdout}\n{process.stderr}"
    except Exception as e:
        return  f"An error occurred during build: {str( e )}"


@mcp.tool( )
def check( ) -> str:
    """Runs static analysis (cppcheck) on the project.
    Ensures that all .cpp and .hpp files follow the project's code formatting rules.
    This command takes no arguments."""
    try:
        process = subprocess.run( [ "python3", "tools/project-builder.py", "--check" ], capture_output=True, text=True )
        if process.returncode == 0:
            return  f"Static analysis successful:\n{process.stdout}"
        else:
            return  f"Static analysis failed:\n{process.stdout}\n{process.stderr}"
    except Exception as e:
        return  f"An error occurred during static analysis: {str( e )}"


@mcp.tool( )
def verify_spacing( files: list[ str ] ) -> str:
    """Verifies if a list of files follows the ( space ) and [ space ] rules.
    Returns a consolidated list of violations with line numbers.
    Useful for distinguishing between real violations and LLM false positives.
    """
    if isinstance( files, str ):
        files = [ files ]

    results = [ ]
    for file_path in files:
        try:
            process = subprocess.run( 
                [ "python3", "tools/ensure_code_formatting.py", "--verify", file_path ], 
                capture_output=True, text=True, check=True 
            )
            violations = json.loads( process.stdout )
            
            if violations:
                message = f"File: {file_path}\n"
                for line_number, line_content in violations:
                    message += f"  Line {line_number}: {line_content}\n"
                results.append( message )
        except Exception as e:
            results.append( f"Error verifying {file_path}: {str(e)}" )
    
    if not results:
        return "No spacing violations found in the provided files."
    
    return "\n".join( results ).strip( )
    

@mcp.tool( )
def verify_rules( files: list[ str ] ) -> str:
    """Verifies if a list of files follows the project's formatting rules (newlines, return spacing, etc.).
    Returns a consolidated list of violations.
    """
    if isinstance( files, str ):
        files = [ files ]

    results = [ ]
    for file_path in files:
        try:
            process = subprocess.run( 
                [ "python3", "tools/ensure_code_formatting.py", "--verify-rules", file_path ], 
                capture_output=True, text=True, check=True 
            )
            violations = json.loads( process.stdout )
            
            if violations:
                message = f"File: {file_path}\n"
                for violation in violations:
                    message += f"  - {violation}\n"
                results.append( message )
        except Exception as e:
            results.append( f"Error verifying {file_path}: {str(e)}" )
    
    if not results:
        return "No rule violations found in the provided files."
    
    return "\n".join( results ).strip( )
    

@mcp.tool( )
def adhoc_tool( params: dict ) -> str:
    """Executes experimental logic defined in tools/adhoc_tool.py.
    This tool is used for prototyping new functionalities.
    The 'params' dictionary is passed to the script.
    """
    try:
        process = subprocess.run( 
            [ "python3", "tools/adhoc_tool.py", json.dumps( params ) ], 
            capture_output=True, text=True, check=True 
        )
        return process.stdout
    except subprocess.CalledProcessError as e:
        return f"Error executing adhoc tool: {e.stderr or e.stdout}"


if __name__ == "__main__":
    mcp.run()

