#!/usr/bin/python3

#   
#   Copyright (C) 2026 Maxwell Aguiar Silva <maxwellaguiarsilva@gmail.com>
#   
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#   
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#   
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#   
#   
#   File:   tools/cpp/cpp_lib/project_core.py
#   Author: Maxwell Aguiar Silva <maxwellaguiarsilva@gmail.com>
#   
#   Created on 2026-01-16 17:38:37
#

import copy
import os
import threading
from lib.common import create_process, deep_update, ensure, get_process_text
from cpp_lib.cpp_config import project_cpp_config
from cpp_lib.project_model import project_model, cpp, hpp
from cpp_lib.clang import clang
from cpp_lib.cppcheck import cppcheck


class binary_builder:
    def __init__( self, cpp_file, project ):
        ensure( cpp_file.is_main, f"file {cpp_file.path} does not contain a main function" )
        
        self.cpp = cpp_file
        self.project = project
        self.binary_path = self.cpp.binary.path
        
        self.dependencies_list = [ self.cpp ] + self.cpp.link_list

    def link( self ):
        if self.project.is_stopped:
            return

        log = self.project.print
        os.makedirs( os.path.dirname( self.binary_path ), exist_ok = True )
        
        object_files = [ c.object.path for c in self.dependencies_list ]
        
        if self.cpp.is_linkage_needed:
            linker_command = self.project.compiler.get_link_command( object_files, self.binary_path )
            
            process = create_process( linker_command, shell = True, check = False )

            if process.returncode != 0:
                log( f"    [link]: {os.path.basename( self.binary_path )} (failed)" )
                log( get_process_text( process ) )
                log( f"linker: {linker_command}" )
                self.project.stop( )
                ensure( False, f"linking failed for {self.binary_path}" )
            else:
                log( f"    [link]: {os.path.basename( self.binary_path )}" )
                log( get_process_text( process ) )
                self.cpp.binary.refresh( )


class project_core:
    def __init__( self, config = { } ):
        self.config = deep_update( copy.deepcopy( project_cpp_config ), config )
        
        self.map = project_model( self.config )
        
        self._lock = threading.Lock( )
        self.flg_stop = threading.Event( )
        self.compiler = clang( self.config )
        self.analyzer = cppcheck( self.config )

        self.binary_list = [ binary_builder( c, self ) for c in self.map.files.values( ) if isinstance( c, cpp ) and c.is_main ]
        
        #   check for binary name collisions
        binaries_by_path = { }
        for b in self.binary_list:
            if b.binary_path in binaries_by_path:
                other_cpp = binaries_by_path[ b.binary_path ].cpp.path
                this_cpp = b.cpp.path
                ensure( False, f"binary name collision: '{os.path.basename( b.binary_path )}' is generated by both '{other_cpp}' and '{this_cpp}'" )
            binaries_by_path[ b.binary_path ] = b

    def stop( self ):
        self.flg_stop.set( )

    @property
    def is_stopped( self ):
        return  self.flg_stop.is_set( )

    def print( self, *args, **kwargs ):
        args = [ a for a in args if a ]
        if not args:
            return

        with self._lock:
            if self.is_stopped:
                return

            print( *args, **kwargs )

    def build( self, cpp_file ):
        if self.is_stopped:
            return

        if not cpp_file.is_compilation_needed:
            self.print( f"    [cached]: {cpp_file.hierarchy}" )
            return

        compiler_command = self.compiler.get_compile_command( cpp_file.path, cpp_file.object.path )

        process = create_process( compiler_command, shell = True, check = False )

        lines = [ f"    [build]: {cpp_file.hierarchy}", get_process_text( process ) ]

        if process.returncode != 0:
            self.stop( )
            ensure( False, f"""compiler: {compiler_command}\nfailed: {"\n".join( lines )}\ncompilation failed for {cpp_file.path}""" )
        else:
            self.print( *lines, sep = "\n" )

        cpp_file.object.refresh( )

    def run_cppcheck( self ):
        if not self.config[ 'quality_control' ][ 'static_analysis' ][ 'enabled' ]:
            return

        build_dir = self.config[ 'paths' ][ 'build' ]
        os.makedirs( build_dir, exist_ok = True )
        
        source_dir = self.config[ 'paths' ][ 'source' ]
        tests_dir = self.config[ 'paths' ][ 'tests' ]
        
        cppcheck_command = self.analyzer.get_command( [ source_dir, tests_dir ] )
        
        self.print( "running static analysis (cppcheck)..." )
        process = create_process( cppcheck_command, shell = True, check = False, capture_output = False, text = False )
        if process.returncode != 0:
            self.print( f"cppcheck: {cppcheck_command}" )
        ensure( process.returncode == 0, "cppcheck failed for the project" )
        self.print( "static analysis completed successfully" )


