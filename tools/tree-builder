#!/usr/bin/python3


import datetime
import glob
import os
import re


class project_file:
    def __init__( self, path, project, base_folder ):
        self.project = project
        self.path = path
        self.modified_at = datetime.datetime.fromtimestamp( os.path.getmtime( path ) )

        relative_path = os.path.relpath( path, base_folder )
        self.hierarchy = os.path.splitext( relative_path )[0]

        with open( path, 'r' ) as f:
            self.content = f.read( )

    def _repr_included_items( self ):
        included_keys = [f'"{k}"' for k in self.included_items.keys()] if hasattr(self, 'included_items') else []
        return "[" + ", ".join(included_keys) + "]"


class cpp( project_file ):
    def __init__( self, path, project ):
        source_folder = project.config["folders"]["source"]
        tests_folder  = project.config["folders"]["tests"]
        build_folder  = project.config["folders"]["build"]
        main_regexp   = project.config["main_regexp"]

        self.is_test = path.startswith( tests_folder )
        base_folder  = tests_folder if self.is_test else source_folder

        super().__init__( path, project, base_folder )
        self.dependencies_modified_at = self.modified_at
        
        # Caminhos no diretório de build
        build_base = os.path.join( build_folder, base_folder )
        self.object_path = os.path.join( build_base, self.hierarchy + ".o" )
        self.dependency_path = self.object_path + ".d"

        self.is_main = bool( re.search( main_regexp, self.content ) )

        if os.path.exists( self.object_path ) and os.path.exists( self.dependency_path ):
            self.compiled_at = datetime.datetime.fromtimestamp( max( 
                os.path.getmtime( self.object_path ), 
                os.path.getmtime( self.dependency_path ) 
            ) )
        else:
            self.compiled_at = None

    def __repr__( self ):
        compiled_at_str = f"\"{self.compiled_at.isoformat()}\"" if self.compiled_at else "null"
        return ( f"{{"
            f"\"hierarchy\": \"{self.hierarchy}\""
            f", \"is_main\": {str(self.is_main).lower()}"
            f", \"is_test\": {str(self.is_test).lower()}"
            f", \"cpp_path\": \"{self.path}\""
            f", \"object_path\": \"{self.object_path}\""
            f", \"dependency_path\": \"{self.dependency_path}\""
            f", \"modified_at\": \"{self.modified_at.isoformat()}\""
            f", \"dependencies_modified_at\": \"{self.dependencies_modified_at.isoformat()}\""
            f", \"compiled_at\": {compiled_at_str}"
            f", \"included_items\": {self._repr_included_items()}"
            f"}}"
        )


class binary_builder:
    def __init__( self, cpp ):
        if not cpp.is_main:
            raise ValueError( f"O arquivo {cpp.path} não contém uma função main." )
        
        self.cpp = cpp
        dist_folder  = self.cpp.project.config["folders"]["dist"]
        
        # O binário terá apenas o nome do arquivo, sem a extensão e sem a hierarquia
        binary_name = os.path.basename( self.cpp.path )
        binary_name = os.path.splitext( binary_name )[0]
        self.binary_path = os.path.join( dist_folder, binary_name )
        
        if os.path.exists( self.binary_path ):
            self.modified_at = datetime.datetime.fromtimestamp( os.path.getmtime( self.binary_path ) )
        else:
            self.modified_at = None

        self.dependencies_list = []
        self._resolve_dependencies()

    def _resolve_dependencies( self ):
        visited = set()
        
        def walk( hierarchy_name ):
            if hierarchy_name in visited:
                return
            visited.add( hierarchy_name )
            
            item = self.cpp.project.hierarchy_items[ hierarchy_name ]
            cpp_obj = item[ "cpp" ]
            hpp_obj = item[ "hpp" ]
            
            if cpp_obj:
                self.dependencies_list.append( cpp_obj )
            
            # Combine includes from both cpp and hpp (if they exist)
            all_includes = set()
            if cpp_obj:
                all_includes.update( cpp_obj.included_items.keys() )
            if hpp_obj:
                all_includes.update( hpp_obj.included_items.keys() )
                
            for incl_hierarchy in all_includes:
                walk( incl_hierarchy )

        walk( self.cpp.hierarchy )

    def __repr__( self ):
        modified_at_str = f"\"{self.modified_at.isoformat()}\"" if self.modified_at else "null"
        dependencies_json = [ f"\"{d.hierarchy}\"" for d in self.dependencies_list ]
        return ( f"{{"
            f"\"hierarchy\": \"{self.cpp.hierarchy}\""
            f", \"binary_path\": \"{self.binary_path}\""
            f", \"modified_at\": {modified_at_str}"
            f", \"dependencies_list\": [{', '.join(dependencies_json)}]"
            f"}}"
        )


class hpp( project_file ):
    def __init__( self, path, project ):
        base_folder = project.config["folders"]["include"]
        super().__init__( path, project, base_folder )

    def __repr__( self ):
        return ( f"{{"
            f"\"hierarchy\": \"{self.hierarchy}\""
            f", \"hpp_path\": \"{self.path}\""
            f", \"modified_at\": \"{self.modified_at.isoformat()}\""
            f", \"included_items\": {self._repr_included_items()}"
            f"}}"
        )

class project:
    def __init__( self, config ):
        self.config = config
        include_list    =   glob.glob( os.path.join( config["folders"]["include"], "**/*.hpp" ), recursive=True )
        source_list     =   glob.glob( os.path.join( config["folders"]["source"], "**/*.cpp" ), recursive=True )
        tests_list      =   glob.glob( os.path.join( config["folders"]["tests"], "**/*.cpp" ), recursive=True )

        self.hpp_list = [hpp( p, self ) for p in include_list]
        self.cpp_list = [cpp( p, self ) for p in source_list + tests_list]
        self.hierarchy_items = self._get_hierarchy_items( )

        self._update_pair_info( )
        self._update_included_items( )
        self.binary_list = [binary_builder( c ) for c in self.cpp_list if c.is_main]

    def _get_hierarchy_items( self ):
        hierarchy_items = {}
        for h in self.hpp_list:
            hierarchy_items.setdefault( h.hierarchy, { "cpp": None, "hpp": None } )[ "hpp" ] = h
        for c in self.cpp_list:
            hierarchy_items.setdefault( c.hierarchy, { "cpp": None, "hpp": None } )[ "cpp" ] = c
        return hierarchy_items

    def _update_pair_info( self ):
        for item in self.hierarchy_items.values( ):
            cpp_obj = item[ "cpp" ]
            hpp_obj = item[ "hpp" ]
            if cpp_obj:
                cpp_obj.hpp = hpp_obj
                if hpp_obj:
                    cpp_obj.dependencies_modified_at = max( cpp_obj.dependencies_modified_at, hpp_obj.modified_at )
            if hpp_obj:
                hpp_obj.cpp = cpp_obj

    def _update_included_items( self ):
        include_pattern = re.compile( r'#include\s+["<]([^">]+)[">]' )
        for obj in self.hpp_list + self.cpp_list:
            obj.included_items = {}
            matches = include_pattern.findall( obj.content )
            for match in matches:
                included_hierarchy = os.path.splitext( match )[0]
                if included_hierarchy in self.hierarchy_items:
                    obj.included_items[included_hierarchy] = self.hierarchy_items[included_hierarchy]

    def __repr__( self ):
        items = [ ]
        for key, value in self.hierarchy_items.items( ):
            cpp_json = str( value[ "cpp" ] ) if value[ "cpp" ] else "null"
            hpp_json = str( value[ "hpp" ] ) if value[ "hpp" ] else "null"
            items.append( f"\"{key}\": {{ \"cpp\": {cpp_json}, \"hpp\": {hpp_json} }}" )
        return "{\n " + "\n ,".join( items ) + "\n}"

    def build( self ):
        print( self.binary_list )


current_project = project( {
     "cpp_version": "c++23"
    ,"file_extension": "cpp"
    ,"file_filter": "*.cpp"
    ,"main_regexp": r"\b(int|auto)\s+main\s*\("
    ,"folders": {
         "source": "source"
        ,"include": "include"
        ,"tests": "tests"
        ,"build": "build"
        ,"dist": "dist"
    }
} )
print( current_project )
current_project.build( )


