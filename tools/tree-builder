#!/usr/bin/python3


import glob
import os
import re


class cpp:
    def __init__( self, path, project ):
        self.project  = project
        self.cpp_path = path

        source_folder = self.project.config["folders"]["source"]
        tests_folder  = self.project.config["folders"]["tests"]
        build_folder  = self.project.config["folders"]["build"]
        main_regexp   = self.project.config["main_regexp"]

        self.is_test = self.__check_if_test( )
        base_folder  = tests_folder if self.is_test else source_folder

        # Remove o prefixo da pasta base e a extensão
        relative_path = os.path.relpath( path, base_folder )
        self.hierarchy = os.path.splitext( relative_path )[0]
        
        # Caminhos no diretório de build
        build_base = os.path.join( build_folder, base_folder )
        self.object_path = os.path.join( build_base, self.hierarchy + ".o" )
        self.dependency_path = self.object_path + ".d"

        with open( path, 'r' ) as f:
            self.content = f.read( )
        self.is_main = bool( re.search( main_regexp, self.content ) )

    def __check_if_test( self ):
        return self.cpp_path.startswith( self.project.config["folders"]["tests"] )

    def __repr__( self ):
        included_keys = [f'"{k}"' for k in self.included_items.keys()] if hasattr(self, 'included_items') else []
        included_items_str = "[" + ", ".join(included_keys) + "]"
        return ( f"{{"
            f"\"hierarchy\": \"{self.hierarchy}\""
            f", \"is_main\": {str(self.is_main).lower()}"
            f", \"is_test\": {str(self.is_test).lower()}"
            f", \"cpp_path\": \"{self.cpp_path}\""
            f", \"object_path\": \"{self.object_path}\""
            f", \"dependency_path\": \"{self.dependency_path}\""
            f", \"included_items\": {included_items_str}"
            f"}}"
        )


class binary_builder:
    def __init__( self, cpp ):
        if not cpp.is_main:
            raise ValueError( f"O arquivo {cpp.cpp_path} não contém uma função main." )
        
        self.cpp = cpp
        dist_folder  = self.cpp.project.config["folders"]["dist"]
        
        # O binário terá apenas o nome do arquivo, sem a extensão e sem a hierarquia
        binary_name = os.path.basename( self.cpp.cpp_path )
        binary_name = os.path.splitext( binary_name )[0]
        self.binary_path = os.path.join( dist_folder, binary_name )

    def __repr__( self ):
        return ( f"{{"
            f"\"hierarchy\": \"{self.cpp.hierarchy}\""
            f", \"binary_path\": \"{self.binary_path}\""
            f"}}"
        )


class hpp:
    def __init__( self, path, project ):
        self.project  = project
        self.hpp_path = path
        base_folder   = self.project.config["folders"]["include"]
        relative_path = os.path.relpath( path, base_folder )
        self.hierarchy = os.path.splitext( relative_path )[0]
        with open( path, 'r' ) as f:
            self.content = f.read( )

    def __repr__( self ):
        included_keys = [f'"{k}"' for k in self.included_items.keys()] if hasattr(self, 'included_items') else []
        included_items_str = "[" + ", ".join(included_keys) + "]"
        return ( f"{{"
            f"\"hierarchy\": \"{self.hierarchy}\""
            f", \"hpp_path\": \"{self.hpp_path}\""
            f", \"included_items\": {included_items_str}"
            f"}}"
        )

class project:
    def __init__( self, config ):
        self.config = config
        include_list    =   glob.glob( os.path.join( config["folders"]["include"], "**/*.hpp" ), recursive=True )
        source_list     =   glob.glob( os.path.join( config["folders"]["source"], "**/*.cpp" ), recursive=True )
        tests_list      =   glob.glob( os.path.join( config["folders"]["tests"], "**/*.cpp" ), recursive=True )

        self.hpp_list = [hpp( p, self ) for p in include_list]
        self.cpp_list = [cpp( p, self ) for p in source_list + tests_list]
        self.binary_list = [binary_builder( c ) for c in self.cpp_list if c.is_main]
        self.hierarchy_items = self.__get_hierarchy_items( )

        self.__update_pair_info( )
        self.__update_included_items( )

    def __get_hierarchy_items( self ):
        hierarchy_items = {}
        for h in self.hpp_list:
            hierarchy_items.setdefault( h.hierarchy, { "cpp": None, "hpp": None } )[ "hpp" ] = h
        for c in self.cpp_list:
            hierarchy_items.setdefault( c.hierarchy, { "cpp": None, "hpp": None } )[ "cpp" ] = c
        return hierarchy_items

    def __update_pair_info( self ):
        for item in self.hierarchy_items.values( ):
            cpp_obj = item[ "cpp" ]
            hpp_obj = item[ "hpp" ]
            if cpp_obj:
                cpp_obj.hpp = hpp_obj
            if hpp_obj:
                hpp_obj.cpp = cpp_obj

    def __update_included_items( self ):
        include_pattern = re.compile( r'#include\s+["<]([^">]+)[">]' )
        for obj in self.hpp_list + self.cpp_list:
            obj.included_items = {}
            matches = include_pattern.findall( obj.content )
            for match in matches:
                included_hierarchy = os.path.splitext( match )[0]
                if included_hierarchy in self.hierarchy_items:
                    obj.included_items[included_hierarchy] = self.hierarchy_items[included_hierarchy]

    def __repr__( self ):
        items = [ ]
        for key, value in self.hierarchy_items.items( ):
            cpp_json = str( value[ "cpp" ] ) if value[ "cpp" ] else "null"
            hpp_json = str( value[ "hpp" ] ) if value[ "hpp" ] else "null"
            items.append( f"\"{key}\": {{ \"cpp\": {cpp_json}, \"hpp\": {hpp_json} }}" )
        return "{\n " + "\n ,".join( items ) + "\n}"

    def build( self ):
        print( self.binary_list )


current_project = project( {
     "cpp_version": "c++23"
    ,"file_extension": "cpp"
    ,"file_filter": "*.cpp"
    ,"main_regexp": r"\b(int|auto)\s+main\s*\("
    ,"folders": {
         "source": "source"
        ,"include": "include"
        ,"tests": "tests"
        ,"build": "build"
        ,"dist": "dist"
    }
} )
print( current_project )
current_project.build( )


